[{"title":"ES6模块","url":"/2021/04/12/ES6%E6%A8%A1%E5%9D%97/","content":"理解模块什么是模块呢，模块模式的中心思想很简单，就是把逻辑分块，个自封装，相互独立，每个模块自行决定向外暴露什么，同时自行决定引入执行那些外部代码。可以把每个模块想象成一个键/值实体，键就是模块文件的路径，值就是模块所暴露的内容。\nES6之前的模块加载器在 ES6 原生支持模块之前，使用模块的 JavaScript 代码本质上是希望使用默认没有的语言特性。因此，必须按照符合某种规范的模块语法来编写代码，另外还需要单独的模块工具把这些模块语法与JavaScript 运行时连接起来。这里的模块语法和连接方式有不同的表现形式，通常需要在浏览器中额外加载库或者在构建时完成预处理。\nCommonJS同步模块定义CommonJS规范了同步依赖的模块定义。主要用于服务端实现模块化，但可以通过工具编译成普通js后再浏览器中运行。CommonJS语法不能直接再浏览器中运行。\nrequire/module.exportsCommonJS通过require指定依赖，通过module.exports暴露公共api。\nvar moduleB = require(&#x27;./moduleB&#x27;);module.exports = &#123; stuff: moduleB.doStuff();&#125;; \n赋值请求模块会加载模块，把模块赋值给变量是非常常见的，但不是必要的，调用**require()**就意味着模块会原封不动的加载进来。\n// moduleAconsole.log(&#x27;moduleA&#x27;);// moduleBrequire(&#x27;./moduleA&#x27;);   // moduleA\n模块永远是单例一个模块不论被require多少次，它永远只被加载一次。模块第一次加载会被缓存，后续加载会从缓冲中取该模块。下面的列子’moduleA’只会被打印一次。\n// moduleAconsole.log(&#x27;moduleA&#x27;);// moduleBconst test1 = require(&#x27;./moduleA&#x27;);   // moduleAconst test2 = require(&#x27;./moduleA&#x27;);test1 === test2;    // true\nAMD异步模块定义AMD的策略是让模块声明自己的依赖，而再浏览器中的模块系统会按需获取依赖，并再依赖加载完成后立即执行依赖他们的模块。AMD模块实现核心使用函数包装模块定义。这样可以防止全局命名污染，并允许加载器库控制何时加载模块。\n// ID 为&#x27;moduleA&#x27;的模块定义。moduleA 依赖 moduleB，// moduleB 会异步加载define(&#x27;moduleA&#x27;, [&#x27;moduleB&#x27;], function(moduleB) &#123; return &#123; stuff: moduleB.doStuff(); &#125;;&#125;); \nES6模块有原生浏览器的支持，集CommonJS和AMD之大成者！\n模块标签以及定义ES6模块作为一整块js代码而存在，通过带有 type=”module” 属性的 &lt;script&gt; 的标签来告诉浏览器要把相关代码当作模块来执行，而不是普通的js脚本文件。模块代码可以是内嵌式，也可是外部文件引入。\n&lt;!-- 内嵌式 --&gt;&lt;script type=&quot;module&quot;&gt; // 模块代码&lt;/script&gt; &lt;!-- 外部文件引入 --&gt;&lt;script type=&quot;module&quot; src=&quot;path/to/myModule.js&quot;&gt;&lt;/script&gt; \n浏览器会在解析到 &lt;script type=”module” &gt;&lt;/script&gt; 标签后立即进行该模块的下载，但不会立即执行，会在文档解析完成后执行，执行顺序就是在页面中出现的顺序。\n&lt;!-- 第二个执行 --&gt;&lt;script type=&quot;module&quot; src=&quot;module.js&quot;&gt;&lt;/script&gt;&lt;!-- 第三个执行 --&gt;&lt;script type=&quot;module&quot; src=&quot;module.js&quot;&gt;&lt;/script&gt;&lt;!-- 第一个执行 --&gt;&lt;script&gt;&lt;script&gt; \n也可以给模块标签添加 async 属性。这样影响就是双重的：不仅模块执行顺序不再与 &lt;script&gt; 标签在页面中的顺序绑定，模块也不会等待文档完成解析才执行。不过，入口模块仍必须等待其依赖加载完成。\nES模块特性\n模块代码只在加载后执行。\n模块只被加载一次。\n模块是单例。\n模块可以定义公共接口，其他模块可以基于这个公共接口观察和交互。\n模块可以请求加载其他模块。\n支持循环依赖。\n模块是异步加载和执行的。\n模块不污染全局命名空间。\n模块默认在严格模式下执行。improt/exportES6模块通过improt进行导入，通过export进行导出。export进行导出有两种方式：命名导出和默认导出。improt命名导出\n\n\n变量声明和导出在一起。// 导出 module.jsexport const test = &#x27;test&#x27;;// 导入import &#123;test&#125; from &#x27;./module.js&#x27;;\n变量声明和导出不在一起。\n\n// 导出 module.jsconst test = &quot;test&quot;;export &#123;test&#125;;// 导入import &#123;test&#125; from &#x27;./module.js&#x27;;\n\n可以混合使用。// 导出 module.jsconst test1 = &quot;test1&quot;;const test2 = &quot;test2&quot;;export const test3 = &quot;test3&quot;;export const test4 = &quot;test4&quot;;export &#123;test1, test2&#125;;// 导入import &#123;test1, test2, test3, test4&#125; from &#x27;./module.js&#x27;;\nas关键字，提供别名。// 导出 module.jsconst test1 = &quot;test1&quot;;const test2 = &quot;test2&quot;;export &#123;test1 as myTest, test2&#125;;// 导入import &#123;myTest, test2&#125; from &#x27;./module.js&#x27;;\n默认导出通过使用default关键字将一个值声明为默认导出，每个模块只能有一个默认导出。\n默认导出，导入默认导出时可以自定义变量名进行接收。// 导出 module.jsconst test = &#x27;test&#x27;;export default test;// 导入import testDemo from &#x27;./module.js&#x27;  // 可自定义变量名\n和命名导出混用。// 导出 module.jsconst test1 = &#x27;test1&#x27;;const test2 = &#x27;test2&#x27;;export &#123;test2&#125;;export default test1;// 导入import &#123;test2&#125; from &#x27;./module.js&#x27;   // 导入命名导出test2import testDemo from &#x27;./module.js&#x27;  // 导入默认导出，可自定义变量名\nas关键字，提供别名。const foo = &#x27;foo&#x27;;// 等同于 export default foo;export &#123; foo as default &#125;; // 这两个 export 语句可以组合为一行const foo = &#x27;foo&#x27;;const bar = &#x27;bar&#x27;;export &#123; foo as default, bar &#125;;\nexport不是必须通过导出的成员才能导入模块。如果不需要模块的特定导出，但仍想加载和执行模块以利用其副作用，可以只通过路径加载它import &#x27;./test.js&#x27;;\n指名导入（可用as关键字）。import &#123; foo, bar, baz as myBaz &#125; from &#x27;./foo.js&#x27;;console.log(foo); // fooconsole.log(bar); // barconsole.log(myBaz); // baz \n默认导入（可用as关键字）。// 等效import &#123; default as foo &#125; from &#x27;./foo.js&#x27;;import foo from &#x27;./foo.js&#x27;;\n命名导出和默认导出的区别也反映在它们的导入上。命名导出可以使用*批量获取并赋值给保存导出集合的别名，而无须列出每个标识符。const foo = &#x27;foo&#x27;, bar = &#x27;bar&#x27;, baz = &#x27;baz&#x27;;export &#123; foo, bar, baz &#125;import * as Foo from &#x27;./foo.js&#x27;;console.log(Foo.foo); // fooconsole.log(Foo.bar); // barconsole.log(Foo.baz); // baz \n默认导入和知名导入混用。// 等效import &#123; default as foo, bar, baz &#125; from &#x27;./foo.js&#x27;;import foo, &#123; bar, baz &#125; from &#x27;./foo.js&#x27;;import foo, * as Foo from &#x27;./foo.js&#x27;;\n\n","categories":["前端进阶"],"tags":["模块化","es6"]},{"title":"scss实现主题切换","url":"/2021/04/12/scss%E5%AE%9E%E7%8E%B0%E4%B8%BB%E9%A2%98%E7%AE%A1%E7%90%86/","content":"主题切换关于主题切换应该不是很陌生，一般都是白天黑夜进行切换提高用户体验。利用 setAttribute 和 scss 可以实现一个便于管理的主题切换。\n实现思路\n利用setAttribute为html设置主题标识。\n使用scss map 管理主题样式。\n遍历scss map 获取对应主题的样式。setAttribute\n设置指定元素上的某个属性值。如果属性已经存在，则更新该值；否则，使用指定的名称和值添加一个新的属性。\n\n\n\n利用setAttribute为html设置属性来区分主题。下面为html设置一个theme属性，属性值为’light’\ndocument.documentElement.setAttribute(&#x27;theme&#x27;, &#x27;light&#x27;)\n添加个按钮用于主题切换，下面例子只设置两种主题，一个是白天’light’，一个是黑天’dark’。\n&lt;body&gt;  &lt;button id=&quot;but&quot;&gt;切换&lt;/button&gt;  &lt;div class=&quot;text&quot;&gt;theme&lt;/div&gt;  &lt;script&gt;    let theme = &#x27;light&#x27;    document.documentElement.setAttribute(&#x27;theme&#x27;, theme)    document.getElementById(&#x27;but&#x27;).onclick = function () &#123;      theme = theme === &#x27;light&#x27; ? &#x27;dark&#x27; : &#x27;light&#x27;      document.documentElement.setAttribute(&#x27;theme&#x27;, theme)    &#125;  &lt;/script&gt;&lt;/body&gt;\n上述代码可实现为html设置一个theme属性，点击按钮进行属性值切换。\n\nscss通过上述代码已经可是实现主题管理了，例如：\n[theme=&quot;light&quot;] .test&#123;  color: #000&#125;[theme=&quot;dark&quot;] .test&#123;  color: #fff&#125;\n通过theme经行匹配使用哪个样式，但是问题在于这样主题样式会散落在各个地方，及其不方便管理，所以要借助scss帮忙管理主题样式。下面介绍一些scss的API。\n定义混合指令@mixin\n混合指令的用法是在 @mixin 后添加名称与样式，比如名为 color 的混合通过下面的代码定义：\n\n@mixin color &#123;  color: #ff0000;&#125;\n混入指令也可以接受传值：\n@mixin color($color) &#123;  color: $color;&#125;\n引用混合样式 @include\n使用 @include 指令引用混合样式，格式是在其后添加混合名称，以及需要的参数（可选）：\n\n// 使用前面定义好的混入 color，并传参数.test&#123;  @include color(#fff);&#125;\n编译为：\n.test&#123;  color: #fff;&#125;\n向混合样式中导入内容@content\n在引用混合样式的时候，可以先将一段代码导入到混合指令中，然后再输出混合样式，额外导入的部分将出现在 @content 标志的地方：\n\n@mixin color &#123;  body &#123;    @content;  &#125;&#125;@include color &#123;  color: #fff;&#125;\n编译为：\nbody&#123;  color: #fff;&#125;\n函数指令@function\nSass 支持自定义函数，并能在任何属性值或 Sass script 中使用，一个函数可以含有多条语句，需要调用 @return 输出结果。\n\n@function themed($key) &#123;  @return $key;&#125;.test&#123;  color: themed(#fff)&#125;\n编译为：\n.test&#123;  color: #fff;&#125;\n父选择器 &amp;\n在嵌套 CSS 规则时，有时也需要直接使用嵌套外层的父选择器，例如，当给某个元素设定 hover 样式时，或者当 body 元素有某个 classname 时，可以用 &amp; 代表嵌套规则外层的父选择器。\n\n@mixin themeify &#123;  [theme = &#x27;dark&#x27;] &amp; &#123;    color: #fff;  &#125;&#125;.test&#123;  @include themeify;&#125;\n编译为：\n[theme = &quot;dark&quot;] .test&#123;  color: #fff;&#125;\nMaps\nMaps可视为键值对的集合，键被用于定位值 在css种没有对应的概念。 和Lists不同Maps必须被圆括号包围，键值对被都好分割 。 Maps中的keys和values可以是sassscript的任何对象。（包括任意的sassscript表达式 arbitrary SassScript expressions） 和Lists一样Maps主要为sassscript函数服务，如 map-get函数用于查找键值，map-merge函数用于map和新加的键值融合，@each命令可添加样式到一个map中的每个键值对。 Maps可用于任何Lists可用的地方，在List函数中 Map会被自动转换为List ， 如 (key1: value1, key2: value2)会被List函数转换为 key1 value1, key2 value2 ，反之则不能。\n\n$themes: (  font_color: #000,  background_color: #fff);.test &#123;  color: map-get($themes, font_color);&#125;\n编译为：\n.test&#123;  color: #000;&#125;\n编译Maps @each\n@each 指令的格式是 $var in , $var 可以是任何变量名，比如 $length 或者 $name，而  是一连串的值，也就是值列表。\n\n$themes: (  light: (    font_color: #000,    background_color: #fff  ),  dark: (    font_color: #FFF,    background_color: #000  ));@mixin themeify&#123;  @each $theme-name, $theme-map in $themes &#123;    [theme = &quot;#&#123;$theme-name&#125;&quot;] &amp; &#123;      color: map-get($theme-map, &#x27;font_color&#x27;)    &#125;  &#125;&#125;;.test&#123;  @include themeify;&#125;\n首先设置了一个名为 $themes 的Maps，其中包含两个名为light和dark的Maps。然后指定一个名为 themeify 的混入，遍历 $themes 。将键指定给theme，在值中取’font_color’。上述代码编译为：\n[theme = &quot;light&quot;] .test&#123;  color: #000;&#125;[theme = &quot;dark&quot;] .test&#123;  color: #fff;&#125;\n实现主题管理通过上述scss的api介绍，已经很容易的实现主题管理了。先创建一个theme.scss 用于管理主题和主题样式。\n// theme.scss$themes: (  light: (    font_color: #000,    background_color: #fff  ),  dark: (    font_color: #FFF,    background_color: #000  ))\n然后创建handle.scss 用于遍历 $themes 提供混入。\n@import &#x27;./theme.scss&#x27;;// 遍历主题map@mixin themeify &#123;  @each $theme-name, $theme-map in $themes &#123;    $theme-map: $theme-map !global;   // 将$theme-map提升到全局防止themed方法获取不到。    [theme = &quot;#&#123;$theme-name&#125;&quot;] &amp; &#123;      @content;    &#125;  &#125;&#125;;// 获取样式的值@function themed($key) &#123;  @return map-get($theme-map, $key);&#125;// 提供color混入@mixin color($color) &#123;  @include themeify&#123;    color: themed($color);  &#125;&#125;// 提供backgroundColor混入@mixin backgroundColor($color) &#123;  @include themeify&#123;    background-color: themed($color);  &#125;&#125;\n使用body&#123;  @include backgroundColor(&#x27;background_color&#x27;);  display: flex;  align-items: center;  justify-content: center;&#125;.text&#123;  font-size: 30px;  @include color(&#x27;font_color&#x27;);&#125;\n上述代码会编译成：\n[theme=&quot;light&quot;] body &#123;    background-color: #fff;&#125;[theme=&quot;dark&quot;] body &#123;    background-color: #000;&#125;body &#123;    display: flex;    align-items: center;    justify-content: center;&#125;[theme=&quot;light&quot;] .text &#123;    color: #000;&#125;[theme=&quot;dark&quot;] .text &#123;    color: #fff;&#125;.text &#123;    font-size: 30px;&#125;\n通过html的theme属性决定使用那套样式。效果图如下：\n\n总结通过scss提供的Maps进行主题管理可以将主题样式都放在一起，方便管理和维护。对于主题的添加和删除也很灵活。\n源码地址源码\n","categories":["css"],"tags":["主题切换"]},{"title":"let 暂存死区","url":"/2021/04/12/let%E6%9A%82%E5%AD%98%E6%AD%BB%E5%8C%BA/","content":"关于let/const通过查阅MDN文档得到的信息。\n\n声明一个块级作用域的本地变量。\n不会再全局声明时创建window对象的属性。\n在同一块级作用域下，不能重复声明。\n暂存性死区。（不能在声明前访问）\nconst声明创建一个值的只读引用，不可变，必须在初始化时赋值。（但这并不意味着它所持有的值是不可变的，只是变量标识符不能重新分配）暂存性死区let 声明的变量在执行时才进行初始化。在变量初始化前访问该变量会导致ReferenceError。该变量处在一个自块顶部到初始化处理得暂存性死区中。let a = 1&#123;  // 暂存性死区 start  console.log(a)  // 暂存性死区 end  let a = 3&#125;\n关于上面代码，结果就是会报ReferenceError错。我的理解是在块作用域内，存在一个自块开始到let声明的一个暂存性死区，在这个暂存性死区中存在一个a这样一个变量，在变量a的暂存性死区中访问a就回出现ReferenceError错误。\n\n关于暂存性死区我的理解是它是一个关于哪个变量的暂存性死区，而不是在一个块作用域中只有一个暂存性死区。\n&#123;  // a,b 的暂存性死区 start  // a 的暂存性死区 end  let a = 1  console.log(a)  console.log(b)  // b 的的暂存性死区 end  let b = 2&#125;\n上述代码console.log(a)正常执行，console.log(b)因为在b的的暂存性死区中访问b，所以报错ReferenceError。\n","categories":["前端进阶"],"tags":["基础","笔记"]},{"title":"前端常用设计模式","url":"/2021/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","content":"单例模式只有一个实例，并且全局可以访问。\n基本单例在全局作用域下var a = {};就是一个单例模式，满足只有一个实例并全局可以访问到。但是全局变量存在过多，很容易造成命名空间污染，还容易被覆盖。以下几种方式可以减小全局变量对命名空间的污染。\n\n使用命名空间看一段有意思动态创建命名空间代码let MyApp = &#123;&#125;;MyApp.namespace = function( name )&#123; let parts = name.split( &#x27;.&#x27; ); let current = MyApp; for ( let i in parts )&#123;  if ( !current[ parts[ i ] ] )&#123;    current[ parts[ i ] ] = &#123;&#125;;  &#125;  current = current[ parts[ i ] ]; &#125;&#125;MyApp.namespace(&#x27;dom.style&#x27;)console.log(MyApp)// 等同于let MyApp = &#123;  dom: &#123;    style: &#123;&#125;  &#125;&#125;\n使用闭包封装私有变量let user = (function () &#123;    let _name = &#x27;皮蛋&#x27;;    let _age = 8    return &#123;        getUserInfo: function () &#123;            return _name + &#x27;-&#x27; + _age        &#125;       &#125;&#125;)()user.getUserInfo()// &#x27;皮蛋-8&#x27;\n惰性单例在需要时才创建实例，而不是一开始就创建实例。// 简单小demo，需要的时候创建一个只有唯一实例的汽车let getCar = (function () &#123;    let car;    return function () &#123;        if (!car) &#123;        car = &#123;            name: &#x27;一汽大众&#x27;        &#125;    &#125;        return car    &#125;&#125;)()// 需要时候创建let car1 = getCar()let car2 = getCar()// 唯一实例car1 === car2()// true\n通用惰性单例从上面惰性单例中，我们实现了在需要时创建单例，但是还是有些不足。\n违反了单一职责原则，创建对象和管理单例都放在getCar内部。\n没有复用性，对于创建car上面代码可以适用，但是创建其他东西的单例就要重新copy一份，这好吗？这不好！\n\n结合上面两点，我们可以对getCar进行重新设计，把管理单例和创建对象分离开。\n// 管理单例function getSingle(fn) &#123;  let result;  return function () &#123;    return result || (result = fn(this, arguments))  &#125;&#125;// 创建carfunction creatCar() &#123;  let car = &#123;    name: &#x27;一汽大众&#x27;  &#125;  return car&#125;// car单例生产器let getCar = getSingle(creatCar)let car1 = getCar()let car2 = getCar()car1 === car2// true// 创建girlfunction creatGirl() &#123;  let girl = &#123;    name: &#x27;qy&#x27;  &#125;  return girl&#125;// girl单例生产器let getGirl = getSingle(creatGirl)let girl1 = getGirl()let girl2 = getGirl()girl1 === girl2// true\n\n策略模式定义一系列算法，把他们一个个封装起来，并且使他们可以相互替换。（感觉策略模式就是在消除代码中的if-else）\n传统if-else的缺点\n函数体积庞大。\n函数缺乏弹性，增加一种新的规则，需要在函数内部实现，违反开放-封闭原则。\n复用性差function s (money) &#123;  return money * 4&#125;function a (money) &#123;  return money * 2&#125;function b (money) &#123;  return money * 4&#125;function Strategy(fn, money) &#123;  fn(money)&#125;Strategy(s, 13000)\n\n代理模式代理模式就是为一个对象提供一个代用品，以便于对他的访问。高内聚低耦合（就是中介）\n基本代理实现一个场景，jd喜欢的女孩是qy，但是不好意思向qy送花，于是让zy（一个jd和qy共同的朋友）帮忙送花，zy要在qy心情好的时候把花送出去，成功率大大提高！。\nfunction Flower() &#123;  this.name = &#x27;rose&#x27;&#125;let jd = &#123;  send: function (traget) &#123;    let flower = new Flower()    traget.receive(flower)  &#125;&#125;let zy = &#123;  receive: function (flower) &#123;    qy.listen(function () &#123;      qy.receive(flower)    &#125;)  &#125;&#125;let qy = &#123;  // 1s之后心情就好了  listen: function (fn) &#123;    setTimeout(() =&gt; &#123;      fn()    &#125;, 1000)  &#125;,  receive: function (flower) &#123;    console.log(&#x27;收到&#x27;, flower)  &#125;&#125;// jd把花给zyjd.send(zy)// 1s之后qy收到了// 收到 Flower &#123;name: &quot;rose&quot;&#125;\n保护代理代理者对被代理者的保护。\n例如现实生活中，qy有很多的追求者，他们都让zy来送花，zy要对送花人做一遍筛选，不能岁的花都要，年龄大于30的就不要。\nfunction Flower() &#123;  this.name = &#x27;rose&#x27;&#125;let jd = &#123;  send: function (traget) &#123;    let flower = new Flower()    traget.receive(this.age, flower)  &#125;,  age: 18&#125;let xx = &#123;  send: function (traget) &#123;    let flower = new Flower()    traget.receive(this.age, flower)  &#125;,  age: 31&#125;let zy = &#123;  receive: function (age, flower) &#123;    if (!this.check(age)) &#123;      console.log(&#x27;滚吧，老头！&#x27;)      return    &#125; else &#123;      console.log(&#x27;我帮你送&#x27;)    &#125;    qy.listen(function () &#123;      qy.receive(flower)    &#125;)  &#125;,  check: function (age) &#123;    return age &gt; 30 ? false : true  &#125;&#125;let qy = &#123;  // 1s之后心情就好了  listen: function (fn) &#123;    setTimeout(() =&gt; &#123;      fn()    &#125;, 1000)  &#125;,  receive: function (flower) &#123;    console.log(&#x27;收到&#x27;, flower)  &#125;&#125;// jd把花给zyjd.send(zy)// 我帮你送// 1s之后// 收到 Flower &#123;name: &quot;rose&quot;&#125;xx.send(zy)// 滚吧，老头！\n虚拟代理把一些开销很大的对象，在需要时才去创建。\n缓存代理为一些开销较大的运算结果提供缓存，当传入参数一样时省略运算直接返回结果。\n// 预算函数function mult () &#123;  console.log(&#x27;开始运算&#x27;)  let result = 1  Array.from(arguments).forEach(v =&gt; &#123;    result *= v  &#125;)  return result&#125;// 代理函数let proxyMult = (function () &#123;  // 缓存对象  let cache = &#123;&#125;  return function () &#123;    let args = [...arguments].join(&#x27;,&#x27;)    if (args in cache) &#123;      return cache[args]    &#125;    return cache[args] = mult(...arguments)  &#125;&#125;)()proxyMult(2,3,1)// 开始运算// 6proxyMult(2,3,1)// 6\n发布-订阅模式是描述对象间一种一对多的关系，当一个对象状态发生改变时，所有依赖于它的对象都会得到通知。在js中，利用事件模型来替带传统的发布-订阅。\n优点\n订阅者不用时刻关注发布者，发布者改变时会通知订阅者进行更新。\n发布者和订阅者不必强耦合在一起，二者虽然不清楚彼此的细节，但不影响他们之间的相互通信。\n\n实现一个全局发布-订阅\n指定一个Event（事件中心）添加一个缓存列表，用于存放订阅者回调函数。\n最后发布消息的时候，遍历缓存列表，依次触发里面的订阅者回调函数。// 事件中心class Event &#123;    constructor() &#123;        this.clientList = &#123;&#125;    &#125;    addListen(type, fn) &#123;        if (!this.clientList[type]) &#123;            this.clientList[type] = []        &#125;        this.clientList[type].push(fn)    &#125;    notify(type) &#123;        if (this.clientList[type]) &#123;            this.clientList[type].forEach(fn =&gt; &#123;                fn()            &#125;)        &#125;    &#125;&#125;// 发布者class Publisher&#123;    constructor() &#123;            &#125;    notify(event, type) &#123;        event.notify(type)    &#125;&#125;// 订阅者class User &#123;    constructor() &#123;        &#125;    want(event, type, fn) &#123;        event.addListen(type, fn)    &#125;&#125;let e = new Event()let p = new Publisher()let u1 = new User()let u2 = new User()// 添加订阅u1.want(e, &#x27;fang&#x27;, function () &#123;    console.log(&#x27;u1 get message&#x27;)&#125;)// 添加订阅u2.want(e, &#x27;fang&#x27;, function () &#123;    console.log(&#x27;u2 get message&#x27;)&#125;)// 发布通知p.notify(e, &#x27;fang&#x27;)\n命令模式命令模式中的命令（command）指的是执行某些特定事情的指令。命令模式常见应用场景如：有时候需要向某些对象发送请求，但不知道请求的接收者是谁，也不知道请求的内容，这时候就需要有一种松耦合的设计程序方式，来消除请求者和接收者直接的耦合。function click(type, fn) &#123;  type.onClick =&#125;\n组合模式\n\n","categories":["前端设计模式"],"tags":["前端","设计模式"]},{"title":"手写Promise","url":"/2021/04/12/%E6%89%8B%E5%86%99Promise/","content":"为何写这篇一是面试的时候始终被问，被问的烦了就自己写一个吧（开始没有太深究实现，不知道为啥，手写Promise一直有人问）。二是看过很多关于手写Promise的文章，也看过Promise/A+的文档，但感觉总是乱乱的，还是自己写一个吧，写了踏实（感觉没啥用啊）。\nPromise实现看别的文章也是一步一步来实现的，我也一步一步来吧，要不然看起来太乱了。本文对应了Promise/A+地址如下：中文 | 英文\n基本Promise首先实现一个基本的Promise，不用考虑太多。\n\n一个 Promise 的当前状态必须为以下三种状态中的一种：等待态（Pending）、执行态（Fulfilled）和拒绝态（Rejected）\nnew Promise时接收一个方法，这里叫这个方法为executor。该方法接受两个参数resolve和reject。\nPromise有一个then方法。该方法注册了两个回调函数，用于接收 promise 的终值或本 promise 不能执行的原因。\n如果状态是Pending时代表executor还没有执行完，需要把then的回调onFulfilled和onRejected放入onResolvedCallbacks和onRejectedCallbacks数组缓存起来等待执行。const PENDING = &#x27;PENDING&#x27;;const FULFILLED = &#x27;FULFILLED&#x27;;const REJECTED = &#x27;REJECTED&#x27;;class Promise &#123;  constructor(executor) &#123;    if (typeof executor !== &#x27;function&#x27;) &#123;      throw TypeError(`Promise resolver $&#123;executor&#125; is not a function`)    &#125;    // 状态    this.status = PENDING;    // 成功值    this.value = undefined;    // 失败原因    this.reason = undefined;    // 存放成功的回调    this.onResolvedCallbacks = [];    // 存放失败的回调    this.onRejectedCallbacks= [];    const resolve = (value) =&gt; &#123;      if (this.status === PENDING) &#123;        this.status = FULFILLED        this.value = value        this.onResolvedCallbacks.forEach(fn =&gt; fn())      &#125;    &#125;    const reject = (reason) =&gt; &#123;      if (this.status === PENDING) &#123;        this.status = REJECTED        this.reason = reason        this.onRejectedCallbacks.forEach(fn =&gt; fn())      &#125;    &#125;    try&#123;      executor(resolve, reject)    &#125; catch (error)&#123;      reject(error)    &#125;  &#125;  then(onFulfilled, onRejected) &#123;    if (this.status === PENDING) &#123;      // 如果promise的状态是 pending，需要将 onFulfilled 和 onRejected 函数存放起来，等待状态确定后，再依次将对应的函数执行      this.onResolvedCallbacks.push(() =&gt; &#123;        onFulfilled(this.value)      &#125;)      this.onRejectedCallbacks.push(() =&gt; &#123;        onRejected(this.reason)      &#125;)    &#125;    if (this.status === FULFILLED) &#123;      onFulfilled(this.value)    &#125;    if (this.status === REJECTED) &#123;      onRejected(this.reason)    &#125;  &#125;&#125;module.exports = Promise\n测试一下代码const Promise = require(&#x27;./promiseMe&#x27;)new Promise(function (resovle, reject) &#123;  console.log(&#x27;Promise start&#x27;)  setTimeout(() =&gt; &#123;    resovle(&#x27;执行完毕&#x27;)  &#125;, 1000)&#125;).then(res =&gt; &#123;  console.log(res)&#125;)// Promise start1s后// 执行完毕\n完整Promise小孩都知道Promise.then支持链式调用、穿透调用等。下面根据Promise/A+不断完善。2.2.1 onFulfilled和onRejected都是可选的参数\n\n\n2.2.1.1. 如果onFulfilled不是一个函数，它必须被忽略\n2.2.1.2. 如果onRejected不是一个函数，它必须被忽略\n\n也就是then的穿透性，例如Promise.then().then()，如果第一个then没有操作，Promise的value或resone会被传递到下个then()。换句话说就是假如第一个then的onFulfilled或onRejected不是个函数就将onFulfilled或onRejected赋值成一个函数。\nthen(onFulfilled, onRejected) &#123;  onFulfilled = typeof onFulfilled === &#x27;function&#x27; ? onFulfilled : v =&gt; v  // 抛出 e 防治被resolve捕获。  onRejected = typeof onRejected === &#x27;function&#x27; ? onRejected : e =&gt; &#123;throw e&#125;  if (this.status === PENDING) &#123;    // 如果promise的状态是 pending，需要将 onFulfilled 和 onRejected 函数存放起来，等待状态确定后，再依次将对应的函数执行    this.onResolvedCallbacks.push(() =&gt; &#123;      onFulfilled(this.value)    &#125;)    this.onRejectedCallbacks.push(() =&gt; &#123;      onRejected(this.reason)    &#125;)  &#125;  if (this.status === FULFILLED) &#123;    onFulfilled(this.value)  &#125;  if (this.status === REJECTED) &#123;    onRejected(this.reason)  &#125;&#125;\n2.2.4. 在执行上下文栈中只包含平台代码之前，onFulfilled或onRejected一定不能被调用 [3.1]\n3.1. 这里“平台代码”意味着引擎、环境以及promise的实现代码。在实践中，这需要确保onFulfilled和onRejected异步地执行，并且应该在then方法被调用的那一轮事件循环之后用新的执行栈执行。这可以用如setTimeout或setImmediate这样的“宏任务”机制实现，或者用如MutationObserver或process.nextTick这样的“微任务”机制实现。由于promise的实现被考虑为“平台代码”，因此在自身处理程序被调用时可能已经包含一个任务调度队列。\n\n将onFulfilled和onRejected包在setTimeout中。\nthen(onFulfilled, onRejected) &#123;  onFulfilled = typeof onFulfilled === &#x27;function&#x27; ? onFulfilled : v =&gt; v  onRejected = typeof onRejected === &#x27;function&#x27; ? onRejected : e =&gt; &#123;throw e&#125;  if (this.status === PENDING) &#123;    // 如果promise的状态是 pending，需要将 onFulfilled 和 onRejected 函数存放起来，等待状态确定后，再依次将对应的函数执行    this.onResolvedCallbacks.push(() =&gt; &#123;      setTimeout(() =&gt; &#123;        onFulfilled(this.value)      &#125;, 0)    &#125;)    this.onRejectedCallbacks.push(() =&gt; &#123;      setTimeout(() =&gt; &#123;        onRejected(this.reason)      &#125;, 0)    &#125;)  &#125;  if (this.status === FULFILLED) &#123;    setTimeout(() =&gt; &#123;      onFulfilled(this.value)    &#125;, 0)  &#125;  if (this.status === REJECTED) &#123;    setTimeout(() =&gt; &#123;      onRejected(this.reason)    &#125;, 0)  &#125;&#125;\n2.2.7. then必须返回一个promise [3.3]\n2.2.7.1. 如果onFulfilled或onRjected返回一个值x，运行promise解决程序[Resolve]\n2.2.7.2. 如果onFulfilled或onRejected抛出一个异常e，promise2必须用e作为原因被拒绝\n2.2.7.3. 如果onFulfilled不是一个函数并且promise1被解决，promise2必须用与promise1相同的值被解决\n2.2.7.4. 如果onRejected不是一个函数并且promise1被拒绝，promise2必须用与promise1相同的原因被拒绝\n\n关于 2.2.7.1 中的promise解决程序后续会完整的介绍，这里先设定 resolvePromise() 就是这个解决程序。\n关于 2.2.7.2 实现思路为将 onFulfilled或onRejected 放在 try…catch 中，如果捕获到异常e，用promise2的reject拒绝。\nthen(onFulfilled, onRejected) &#123;  onFulfilled = typeof onFulfilled === &#x27;function&#x27; ? onFulfilled : v =&gt; v  onRejected = typeof onRejected === &#x27;function&#x27; ? onRejected : e =&gt; &#123;throw e&#125;  let promise2 = new Promise((resovle, reject) =&gt; &#123;    if (this.status === PENDING) &#123;      // 如果promise的状态是 pending，需要将 onFulfilled 和 onRejected 函数存放起来，等待状态确定后，再依次将对应的函数执行      this.onResolvedCallbacks.push(() =&gt; &#123;        setTimeout(() =&gt; &#123;          try &#123;            let x = onFulfilled(this.value)            resolvePromise(promise2, x, resovle, reject)          &#125; catch (error) &#123;            reject(error)          &#125;        &#125;, 0)      &#125;)      this.onRejectedCallbacks.push(() =&gt; &#123;        setTimeout(() =&gt; &#123;          try &#123;            let x = onRejected(this.reason)            resolvePromise(promise2, x, resovle, reject)          &#125; catch (error) &#123;            reject(error)          &#125;        &#125;, 0)      &#125;)    &#125;    if (this.status === FULFILLED) &#123;      setTimeout(() =&gt; &#123;        try &#123;          let x = onFulfilled(this.value)          resolvePromise(promise2, x, resovle, reject)        &#125; catch (error) &#123;          reject(error)        &#125;      &#125;, 0)    &#125;    if (this.status === REJECTED) &#123;      setTimeout(() =&gt; &#123;        try &#123;          let x = onRejected(this.reason)          resolvePromise(promise2, x, resovle, reject)        &#125; catch (error) &#123;          reject(error)        &#125;      &#125;, 0)    &#125;  &#125;)  return promise2&#125;\nPromise解决程序关于promise解决程序应该是promise中最核心最绕的地方了。可以说前面的Promise就是利用了 发布订阅 模式完成依赖收集和触发执行实现Promise对于异步的处理。但是Promise的 链式调用 以及 嵌套 的实现都是基于promise解决程序。Promise/A+定义如下:\n\npromise解决程序是一个抽象操作，它以一个promise和一个值作为输入，我们将其表示为[[Resolve]](promise, x)。如果x是一个thenable，它尝试让promise采用x的状态，并假设x的行为至少在某种程度上类似于promise。否则，它将会用值x解决 promise。这种thenable的特性使得Promise的实现更具有通用性：只要其暴露一个遵循Promise/A+协议的then方法即可。这同时也使遵循Promise/A+规范的实现可以与那些不太规范但可用的实现能良好共存。\n\n我的理解是 promise解决程序是为了解决x如果是一个Promise，那么promise2应该resolve/reject什么的一个定义。主要思路是如果x是一个Promise，那么执行x的then的方式确定promise2的状态，类似于将x.then往promise2.then上的移植\n\n2.3.1. 如果promise和x引用同一个对象，用一个TypeError作为原因来拒绝promise\n2.3.2. 如果x是一个promise，采用它的状态：[3.4]\n2.3.2.1. 如果x是等待态，promise必须保持等待状态，直到x被解决或拒绝\n\n\n\n2.3.2.2. 如果x是解决态，用相同的值解决promise2.3.2.3. 如果x是拒绝态，用相同的原因拒绝promise\n\n2.3.3. 否则，如果x是一个对象或函数\n2.3.3.1. 让then成为x.then。[3.5]\n2.3.3.2. 如果检索属性x.then导致抛出了一个异常e，用e作为原因拒绝promise\n2.3.3.3. 如果then是一个函数，用x作为this调用它。then方法的参数为俩个回调函数，第一个参数叫做resolvePromise，第二个参数叫做rejectPromise：\n2.3.3.3.1. 如果resolvePromise用一个值y调用，运行[[Resolve]](promise, y)。译者注：这里再次调用[Resolve]，因为y可能还是promise\n2.3.3.3.2. 如果rejectPromise用一个原因r调用，用r拒绝promise。译者注：这里如果r为promise的话，依旧会直接reject，拒绝的原因就是promise。并不会等到promise被解决或拒绝\n2.3.3.3.3. 如果resolvePromise和rejectPromise都被调用，或者对同一个参数进行多次调用，那么第一次调用优先，以后的调用都会被忽略。译者注：这里主要针对thenable，promise的状态一旦更改就不会再改变。\n2.3.3.3.4. 如果调用then抛出了一个异常e,\n\n\n2.3.3.4. 如果then不是一个函数，用x解决promise\n\n\n2.3.4. 如果x不是一个对象或函数，用x解决promiseconst resolvePromise = (promise2, x, resolve, reject) =&gt; &#123;  // Promise/A+ 2.3.1  if (promise2 === x) &#123;    return reject(new TypeError(&#x27;Chaining cycle detected for promise #&lt;Promise&gt;&#x27;))  &#125;  // Promise/A+ 2.3.3.3.3 只能调用一次  let called;  // Promise/A+ 2.3.2  // Promise/A+ 2.3.3  if ((typeof x === &#x27;object&#x27; &amp;&amp; x != null) || typeof x === &#x27;function&#x27;)&#123;    try &#123;      // Promise/A+ 2.3.3.1      let then = x.then      // Promise/A+ 2.3.3.3      if (typeof then === &#x27;function&#x27;) &#123;        then.call(x, y =&gt; &#123; // Promise/A+ 2.3.3.3.1 -- 递归调用，y可能也是Promise          if (called) return;          called = true;          resolvePromise(promise2, y, resolve, reject);         &#125;, r =&gt; &#123; // Promise/A+ 2.3.3.3.2          if (called) return;          called = true;          reject(r)        &#125;)      &#125; else &#123;        // Promise/A+ 2.3.3.4        resolve(x)      &#125;    &#125; catch (error) &#123;      // Promise/A+ 2.3.3.2 在try中可能改变了status      if (called) return;      called = true;      reject(error)    &#125;  &#125; else &#123;    // Promise/A+2.3.4    resolve(x)  &#125;&#125;\n完整代码const PENDING = &#x27;PENDING&#x27;;const FULFILLED = &#x27;FULFILLED&#x27;;const REJECTED = &#x27;REJECTED&#x27;;const resolvePromise = (promise2, x, resolve, reject) =&gt; &#123;  // Promise/A+ 2.3.1  if (promise2 === x) &#123;    return reject(new TypeError(&#x27;Chaining cycle detected for promise #&lt;Promise&gt;&#x27;))  &#125;  // Promise/A+ 2.3.3.3.3 只能调用一次  let called;  // Promise/A+ 2.3.2  // Promise/A+ 2.3.3  if ((typeof x === &#x27;object&#x27; &amp;&amp; x != null) || typeof x === &#x27;function&#x27;)&#123;    try &#123;      // Promise/A+ 2.3.3.1      let then = x.then      // Promise/A+ 2.3.3.3      if (typeof then === &#x27;function&#x27;) &#123;        then.call(x, y =&gt; &#123; // Promise/A+ 2.3.3.3.1 -- 递归调用，y可能也是Promise          if (called) return;          called = true;          resolvePromise(promise2, y, resolve, reject);         &#125;, r =&gt; &#123; // Promise/A+ 2.3.3.3.2          if (called) return;          called = true;          reject(r)        &#125;)      &#125; else &#123;        // Promise/A+ 2.3.3.4        resolve(x)      &#125;    &#125; catch (error) &#123;      // Promise/A+ 2.3.3.2 在try中可能改变了status      if (called) return;      called = true;      reject(error)    &#125;  &#125; else &#123;    // Promise/A+2.3.4    resolve(x)  &#125;&#125;class Promise &#123;  constructor(executor) &#123;    if (typeof executor !== &#x27;function&#x27;) &#123;      throw TypeError(`Promise resolver $&#123;executor&#125; is not a function`)    &#125;    // 状态    this.status = PENDING;    // 成功值    this.value = undefined;    // 失败原因    this.reason = undefined;    // 存放成功的回调    this.onResolvedCallbacks = [];    // 存放失败的回调    this.onRejectedCallbacks= [];    const resolve = (value) =&gt; &#123;      if(value instanceof Promise)&#123;        return value.then(resolve,reject)      &#125;      if (this.status === PENDING) &#123;        this.status = FULFILLED        this.value = value        this.onResolvedCallbacks.forEach(fn =&gt; fn())      &#125;    &#125;    const reject = (reason) =&gt; &#123;      if (this.status === PENDING) &#123;        this.status = REJECTED        this.reason = reason        this.onRejectedCallbacks.forEach(fn =&gt; fn())      &#125;    &#125;    try&#123;      executor(resolve, reject)    &#125; catch (error)&#123;      reject(error)    &#125;  &#125;  then(onFulfilled, onRejected) &#123;    onFulfilled = typeof onFulfilled === &#x27;function&#x27; ? onFulfilled : v =&gt; v    onRejected = typeof onRejected === &#x27;function&#x27; ? onRejected : e =&gt; &#123;throw e&#125;    let promise2 = new Promise((resovle, reject) =&gt; &#123;      if (this.status === PENDING) &#123;        // 如果promise的状态是 pending，需要将 onFulfilled 和 onRejected 函数存放起来，等待状态确定后，再依次将对应的函数执行        this.onResolvedCallbacks.push(() =&gt; &#123;          setTimeout(() =&gt; &#123;            try &#123;              let x = onFulfilled(this.value)              resolvePromise(promise2, x, resovle, reject)            &#125; catch (error) &#123;              reject(error)            &#125;          &#125;, 0)        &#125;)        this.onRejectedCallbacks.push(() =&gt; &#123;          setTimeout(() =&gt; &#123;            try &#123;              let x = onRejected(this.reason)              resolvePromise(promise2, x, resovle, reject)            &#125; catch (error) &#123;              reject(error)            &#125;          &#125;, 0)        &#125;)      &#125;      if (this.status === FULFILLED) &#123;        setTimeout(() =&gt; &#123;          try &#123;            let x = onFulfilled(this.value)            resolvePromise(promise2, x, resovle, reject)          &#125; catch (error) &#123;            reject(error)          &#125;        &#125;, 0)      &#125;      if (this.status === REJECTED) &#123;        setTimeout(() =&gt; &#123;          try &#123;            let x = onRejected(this.reason)            resolvePromise(promise2, x, resovle, reject)          &#125; catch (error) &#123;            reject(error)          &#125;        &#125;, 0)      &#125;    &#125;)    return promise2  &#125;&#125;module.exports = Promise\n源码地址源码代码出处面试官：“你能手写一个 Promise 吗”\n\n","categories":["前端进阶"],"tags":["手写"]}]